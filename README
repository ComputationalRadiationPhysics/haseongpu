=======================================
#         OCTRACE                     #
=======================================
#                                     #
# Author : Erik Zenker                #
#          Carlchristian Eckert       #
#          Marius Melzer              #
#                                     #
# Licence: GPLv3                      #
#                                     #
=======================================

## Descrition ##


## Dependencies ##

   Software:
   + make
   + gcc 4.4.1
   + cuda 5.0

   Optional:
   + octave / matlab
   + paraview
   
   Hardware:
   + Nvidia device >= Compute capability 2.0 (at least fermi)

## Installation ##

   run : make

## Usage ##

   + MATLAB compatible interface
   + C-Application interface

## MATLAB compatible interface ##

   * Add calcPhiASE.m to your matlab path
   * Call calcPhiASE from your matlab script 
     like following:

   [phiASE, MSE, nRays] = calcPhiASE(points,
		  		     trianglePointIndices,
				     betaCell,
				     betaVolume,
				     triangleNormalsX,
				     triangleNormalsY,
				     triangleNeighbors,
				     triangleSurface,
				     triangleCenterX,
				     triangleCenterY,
				     triangleNormalPoint,
				     forbiddenEdge,
				     minRaysPerSample,
				     maxRaysPerSample,
				     nTot,
				     thickness,
				     laserParameter,
				     crystal,
				     numberOfLevels)
  
  * The returned values are represented as
    tow-dimensional matrices in which columns are
    slice indices(levels) and rows are point
    indices. The value for the ith point and jth 
    slice can then be optained by MATLAB with:
    	  
	  value = values(i,j);

### Input argument description ### 
    In the following all arguments of the MATLAB call are described.
    You will find on each point a head with datatype (an array when
    in brackets []), the size of the array and to which set of
    numbers the array belongs.


   * points [float], in {0, ..., numberOfPoints}, size = numberOfPoints
     The coordinates of the triangle vertices. All x coordinates followed by all
     of the y coordinates of the triangle vertices
     structure: [x_1, x_2, ... x_n, y_1, y_2, ... y_n] (n == numberOfPoints)

   * triangleNormalsX [float], size = numberOfTriangles * 3
     The x coordinate of the normal vectors for each triangle edge.
     It is ordered as follows:
     [ triangle1_edge0, triangle2_edge0, ... triangleN_edge0, triangle1_edge1, triangle2_edge1, ... ]
     i.e. all first edges of each triangle, followed by all second edges of each triangle and so on.

   * triangleNormalsY [float], size = numberOfTriangles * 3
     The y coordinate of the normal vectors for each triangle edge.
     It is ordered as follows:
     [ triangle1_edge0, triangle2_edge0, ... triangleN_edge0, triangle1_edge1, triangle2_edge1, ... ]
     i.e. all first edges of each triangle, followed by all second edges of each triangle and so on.

   * triangleNormalPoint [unsigned], in {0, ...,  numberOfPoints}, size = numberOfTriangles * 3
     Contains indices to the point where the
     triangleNormalVectors start. For each Triangle 3 points (3 edges)
     are stored in this list. Indices point to locations in "points" 
     (i.e. normal vectors start at triangle vertices!)l
     Structure is VERY similar to triangles: 
     [ triangle1_p0, triangle2_p0, ... triangleN_p0, triangle1_p1, triangle2_p1, ... ]

   * forbiddenEdge [int], in {-1,0,1,2,4}, size = 5
     Describes the relation of edge indices of adjacent triangles
     -1 means, there is no adjacent triangle to that edge
     0,1,2 describes the index of the edge as seen from the ADJACENT triangle
     Order of data is similar to normalVec:
     [ triangle1_edge0, triangle2_edge0, ... triangleN_edge0, triangle1_edge1, triangle2_edge1, ... ]
     i.e. all first edges of each triangle, followed by all second edges of each triangle and so on.

   * triangleNeighbors [int], in {-1,0,1,2,4}, size = 5
     Describes the neighnor relation of triangles to each other.
     Each entry corresponds to a triangleID (see "triangles") which
     is adjacent to the current triangle and edge.
     Structure is similar to "forbidden":
     [ triangle1_edge0, triangle2_edge0, ... triangleN_edge0, triangle1_edge1, triangle2_edge1, ... ]
   
   * trianglePointIndices [int] in {0, ..., numberOfPoints}, size = numberOfTriangles * 3
     Contains the indices to access the "points" datastructure 
     (each triangle has 3 points as vertices). Each entry is an
     index from 0 to numberOfPoints, corresponding to the positions 
     of a vertex in "points".
     Structure as follows:
     [ triangle1A, triangle2A, ... triangleNA, triangle1B, triangle2B, ... triangleNB, triangle1C, ... ]
     i.e. for triangles with vertices A,B,C there are all the indices
     of the A-vertices, followed by all the B and C vertices.

   * thickness float, size = 1
     Thickness of one prism level of the mesh.

   * numberOfLevels unsigned, size = 1
     Total number of levels of the mesh. Thus the total thickness
     of the mesh is thickness * numberOfLevels!

   * nTot float
     Doping of the active gain medium

  * betaVolume [float], size = numberOfTriangles * numberOfLevels - 1
     Stimulus in the volume (prisms).
     Beta values for all prisms ordered accordingly to the prismIDs:
     prismID = triangleID + layer * numberOfTriangles.
     Therefore, all betaValues for a layer are grouped together

   * laserParameter [float] 
     Is a structure for the laser parameters (wavelength sigmas)
     struct(s_abs, VALUES, s_ems, VALUES)

   * crystal [float]
     Is a structure for the crystal parameters 
     crystal.tfluo describes the crystalFluorescence of the active gain medium.

   * betaCells [float]
     Stimulus in the sample points.

   * triangleSurfaces [float], size = numberOfTriangles
     The sizes of the surfaces of each triangle, ordered by the triangleID.

   * triangleCenterX [float], size = numberOfTriangles
     The x coordinates of the center points for each triangle
     ordered by TriangleID.

   * triangleCenterY [float], size = numberOfTriangles
     The y coordinates of the center points for each triangle
     ordered by TriangleID.


     ## MISSING IN MATLAB INTERFACE ##
   * cladType [int], size = numberOfTriangles
     Sets cladding index for triangles {0,1,2,...}

   * cladNum unsigned, size = 1
     Set which cladding to use

   * cladAbs float, size = 1
     Absorption coefficient of cladding

   * refractiveIndices [float], size = 4
     Describes the refractive indices of the active
     gain medium top and bottom planes.
     It is structured as follows:
     {bottomInside, bottomOutside, topInside, topOutside}
     bottomInside = topInside (because it is the same medium)

   * reflectivities [float], in {0, ...,1}, size = 2 * numberOfTriangles
     Defines the reflectivities of prism planes.
     First the reflectivities of bottom plane and then the reflectivities
     of top plane. Both it ordered by TriangleID.

   * maxRays unsigned, size = 1
     Maximal number of rays for adaptive sampling
 
   * mse_threshold float, size = number of wavelength
      Sets the maximal MSE of the ASE value for each wavelength.
      If a sample-point does not reach this MSE-threshold, the number 
      of rays per sample-point will be increased upto maxrays.

   * useReflections bool, size = 1
     Switch to activate reflections
    

## Synopsis ##

   Command:
     ./bin/calcPhiAse [OPTIONS] 

   Options:
    --input
      Absolut path to the experiment location.
      This folder contains several .txt files usually
      generated by an matlab script. The content of this
      .txt files contains all experiment data you need
      to run one experiment.
    --output
      Absolute path to a writable location.
      Is used to write vtk files and input for
      matlab script.

    --mode=[for_loops|ray_propagation_gpu|mpi]
      Defines the runmode/algorithm to start the
      simulation with. Mode "for_loops" is the original
      algorithm based on single core cpu. Mode "ray_propagation_gpu"
      is the parallel algorithm based on nvidia cuda
      devices with Pthreads. Mode "mpi" is a parallel mpi
      implementation for clusters.

    --rays=
      Sets the minimum number of rays per sample-point in the
      crystal structure.

    --maxrays=
      Sets the maximal number of rays per sample-point. The number
      of rays per sample-point will vary between minimum and
      maximum number of rays in dependance of a MSE-Threshold.
      (see --mse-threshold)

    --compare=
      Is the location of a .vtk file with that you want to compare
      your solution. It is good to recognize stastical differences
      between different rays counts.

    --write-vtk
      Write phiASE, dndtASE, mse, totalRays for every sample a .vtk file
      
    --maxgpus=
      Set the maximum number of gpus. "mpi" mode should set this
      to 1 and "ray_propagation_gpu" to the maximum number
      of Gpus on the node. If you don't set it, it will
      be set to the maximum automatically.

    --min_sample_i=
      Index of the first sample point (normally 0).

    --max_sample_i=
      Index of the last sample point (numberOfSample - 1).
          
    --verbosity=
      Add the following for different verbosity levels:
      0  : quiet
      1  : error
      2  : warning
      4  : info
      8  : statistics
      16 : debug

    --reflection
      Use reflection on upper and lower plane of gain
      medium. Maximal number of reflections will be
      calculated

    --mse-threshold=
      Algorithm tries to stay under this threshold
      by adaptive and repetitive sampling.

    --repetitions=
      Number of repetitions, that will be done
      when mse-threshold was not met.

## Example ##

* 4 GPUs, 10K to 100K Rays, 4 Repetitions ...

./bin/calcPhiASE --input=/input/
		 --output=/tmp/ 
		 --mode=ray_propagation_gpu 
		 --rays=10000 
		 --max_rays=100000 
		 --reflection
		 --repetitions=4
		 --maxgpu=4
		 --min_sample_i=0
		 --max_sample_i=1234
		 --mse-threshold=0.05

* MPI with 4 GPUs per node
mpiexec -npernode 4 ./bin/calcPhiASE  --input=/input/
		     		      --output=/tmp/ 
				      --mode=mpi
				      --rays=10000 
				      --max_rays=100000 
				      --reflection
				      --repetitions=4
				      --maxgpu=1
				      --min_sample_i=0
				      --max_sample_i=1234
				      --mse-threshold=0.05
		 
